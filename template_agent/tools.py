from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Any, ClassVar, Sequence

from myagent.tool.base_tool import BaseTool, ToolResult


# -----------------------------
# Data structures
# -----------------------------


@dataclass
class SectionTask:
    """A single report section task proposed by the planner.

    Attributes:
        id: 1-indexed section identifier
        title: Section title
        objective: What this section should convey or accomplish
        hints: Optional list of bullet hints or key points
        required_inputs: Optional file hints (e.g., ["workspace/data.csv"]) for solver
        notes: Any extra guidance or formatting constraints
    """

    id: int
    title: str
    objective: str
    hints: list[str]
    required_inputs: list[str]
    notes: str | None = None

    def short_summary(self) -> str:
        tip = f" | Hints: {', '.join(self.hints[:2])}" if self.hints else ""
        return f"[Section {self.id}] {self.title}: {self.objective}{tip}"


def _ensure_string_list(values: Any) -> list[str]:
    if not values:
        return []
    if isinstance(values, (str, bytes)):
        return [str(values).strip()] if str(values).strip() else []
    if not isinstance(values, Sequence):
        return []
    return [str(item).strip() for item in values if str(item).strip()]


def _parse_section_task(task: dict[str, Any]) -> SectionTask:
    try:
        sec_id = int(task["id"])
        if sec_id <= 0:
            raise ValueError("Section id must be positive.")
    except Exception as exc:
        raise ValueError(f"Invalid section id in task: {task}") from exc

    title = str(task["title"]).strip()
    objective = str(task["objective"]).strip()
    if not title or not objective:
        raise ValueError(f"Task {sec_id} missing title or objective")

    hints = _ensure_string_list(task.get("hints"))
    required_inputs = _ensure_string_list(task.get("required_inputs"))
    notes = str(task.get("notes")).strip() if task.get("notes") else None

    return SectionTask(
        id=sec_id,
        title=title,
        objective=objective,
        hints=hints,
        required_inputs=required_inputs,
        notes=notes,
    )


# -----------------------------
# Planner tools
# -----------------------------


class SectionPlanSubmissionTool(BaseTool):
    """Collect section tasks generated by the planning agent."""

    name: str = "submit_section_plan"
    description: str = (
        "Submit the finalized section plan for the report."
    )
    parameters: ClassVar[dict[str, Any]] = {
        "type": "object",
        "properties": {
            "tasks": {
                "type": "array",
                "description": "List of section tasks for the report (1 task per section).",
                "items": {
                    "type": "object",
                    "properties": {
                        "id": {"type": "integer", "description": "1-indexed section identifier"},
                        "title": {"type": "string", "description": "Section title"},
                        "objective": {"type": "string", "description": "What this section must convey"},
                        "hints": {"type": "array", "items": {"type": "string"}},
                        "required_inputs": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "Optional input file hints for solver (e.g., workspace paths)",
                        },
                        "notes": {"type": "string"},
                    },
                    "required": ["id", "title", "objective"],
                },
            }
        },
        "required": ["tasks"],
    }

    def __init__(self) -> None:
        super().__init__()
        self._tasks: list[SectionTask] = []

    async def execute(self, tasks: Sequence[dict[str, Any]]) -> ToolResult:  # type: ignore[override]
        try:
            parsed = [_parse_section_task(t) for t in tasks]
        except ValueError as exc:
            return ToolResult(error=str(exc))

        ids = [t.id for t in parsed]
        if len(ids) != len(set(ids)):
            return ToolResult(error="Section task IDs must be unique")

        parsed.sort(key=lambda t: t.id)
        self._tasks = parsed
        overview = ["âœ… Section plan received:"] + [f"- {t.short_summary()}" for t in parsed]
        return ToolResult(output="\n".join(overview), system=f"Section planning completed with {len(parsed)} tasks")

    def get_tasks(self) -> list[SectionTask]:
        return list(self._tasks)


class ListLocalTemplatesTool(BaseTool):
    """List available templates under template_agent/workdir/template."""

    name: str = "list_local_templates"
    description: str = "List markdown templates in template_agent/workdir/template directory"
    parameters: ClassVar[dict[str, Any]] = {
        "type": "object",
        "properties": {},
        "required": [],
    }

    async def execute(self) -> ToolResult:  # type: ignore[override]
        base = Path(__file__).resolve().parent / "workdir" / "template"
        if not base.exists():
            return ToolResult(error=f"Template directory not found: {base}")
        files = sorted([p for p in base.rglob("*.md") if p.is_file()])
        if not files:
            return ToolResult(output="No templates found")
        listing = [f"- {p.relative_to(base)}" for p in files]
        return ToolResult(output="\n".join(["Available templates:", *listing]))


class ReadLocalFileTool(BaseTool):
    """Read a local file under restricted roots (template_agent/workdir or workspace)."""

    name: str = "read_local_file"
    description: str = (
        "Read a text file from allowed directories: template_agent/workdir or workspace."
    )
    parameters: ClassVar[dict[str, Any]] = {
        "type": "object",
        "properties": {
            "path": {"type": "string", "description": "Relative path from allowed roots"},
        },
        "required": ["path"],
    }

    def _resolve_allowed(self, path: str) -> Path | None:
        rel = Path(path)
        roots = [
            Path(__file__).resolve().parent / "workdir",
            Path(__file__).resolve().parents[1] / "workspace",
        ]
        for root in roots:
            candidate = (root / rel).resolve()
            try:
                candidate.relative_to(root.resolve())
            except Exception:
                continue
            if candidate.exists() and candidate.is_file():
                return candidate
        return None

    async def execute(self, path: str) -> ToolResult:  # type: ignore[override]
        target = self._resolve_allowed(path)
        if not target:
            return ToolResult(error=f"Access denied or file not found: {path}")
        try:
            text = target.read_text(encoding="utf-8")
            return ToolResult(output=text, system=f"Read file: {path}")
        except Exception as exc:
            return ToolResult(error=f"Failed to read {path}: {exc}")


class ListLocalDirTool(BaseTool):
    """List directory contents under allowed roots (template_agent/workdir or workspace)."""

    name: str = "list_local_dir"
    description: str = (
        "List files and subdirectories under a path relative to template_agent/workdir or workspace."
    )
    parameters: ClassVar[dict[str, Any]] = {
        "type": "object",
        "properties": {
            "path": {"type": "string", "description": "Relative directory path to list"},
        },
        "required": ["path"],
    }

    def _resolve_allowed_dir(self, path: str) -> Path | None:
        rel = Path(path)
        roots = [
            Path(__file__).resolve().parent / "workdir",
            Path(__file__).resolve().parents[1] / "workspace",
        ]
        for root in roots:
            candidate = (root / rel).resolve()
            try:
                candidate.relative_to(root.resolve())
            except Exception:
                continue
            if candidate.exists() and candidate.is_dir():
                return candidate
        return None

    async def execute(self, path: str) -> ToolResult:  # type: ignore[override]
        target = self._resolve_allowed_dir(path)
        if not target:
            return ToolResult(error=f"Access denied or directory not found: {path}")
        try:
            entries = sorted(target.iterdir(), key=lambda p: (p.is_file(), p.name.lower()))
            lines: list[str] = [f"Listing for {path}:"]
            for p in entries:
                kind = "FILE" if p.is_file() else "DIR"
                relpath = p.name
                lines.append(f"- [{kind}] {relpath}")
            return ToolResult(output="\n".join(lines))
        except Exception as exc:
            return ToolResult(error=f"Failed to list {path}: {exc}")


# -----------------------------
# Solver tool
# -----------------------------


class SectionDraftTool(BaseTool):
    """Capture final section draft produced by a solver agent."""

    name: str = "submit_section_draft"
    description: str = (
        "Submit the finalized section draft. Provide id, title, markdown content, and optional tables."
    )
    parameters: ClassVar[dict[str, Any]] = {
        "type": "object",
        "properties": {
            "section": {
                "type": "object",
                "properties": {
                    "id": {"type": "integer"},
                    "title": {"type": "string"},
                    "content": {"type": "string", "description": "Markdown content for this section"},
                    "tables": {
                        "type": "array",
                        "items": {"type": "object"},
                        "description": "Optional structured tables; when present also include as markdown",
                    },
                },
                "required": ["id", "title", "content"],
            }
        },
        "required": ["section"],
    }

    def __init__(self, expected_id: int | None = None) -> None:
        super().__init__()
        self._expected_id = expected_id
        self._section: dict[str, Any] | None = None

    async def execute(self, section: dict[str, Any]) -> ToolResult:  # type: ignore[override]
        if self._expected_id is not None and section.get("id") != self._expected_id:
            return ToolResult(error=f"Section id mismatch. Expected {self._expected_id}, got {section.get('id')!r}")
        # Minimal validation
        if not str(section.get("title", "")).strip() or not str(section.get("content", "")).strip():
            return ToolResult(error="Section title and content are required")
        self._section = {
            "id": int(section["id"]),
            "title": str(section["title"]).strip(),
            "content": str(section["content"]).strip(),
            **({"tables": section.get("tables")} if section.get("tables") is not None else {}),
        }
        return ToolResult(output=f"Draft stored for section {section['id']}: {section['title']}")

    def get_section(self) -> dict[str, Any] | None:
        return self._section


# -----------------------------
# Aggregation helper
# -----------------------------


class RenderMarkdownReportTool(BaseTool):
    """Render a markdown report from section drafts and optional metadata.

    This tool is used by the pipeline aggregator (not by LLM) to assemble
    the final report. It can optionally write the report into `workspace/`.
    """

    name: str = "render_markdown_report"
    description: str = "Assemble sections into a markdown report"
    parameters: ClassVar[dict[str, Any]] = {
        "type": "object",
        "properties": {
            "title": {"type": "string"},
            "sections": {"type": "array", "items": {"type": "object"}},
            "output_path": {"type": "string", "description": "Optional path under workspace/ to save"},
            "front_matter": {"type": "object"},
        },
        "required": ["title", "sections"],
    }

    async def execute(
        self,
        *,
        title: str,
        sections: Sequence[dict[str, Any]],
        output_path: str | None = None,
        front_matter: dict[str, Any] | None = None,
    ) -> ToolResult:  # type: ignore[override]
        lines: list[str] = []
        if front_matter:
            lines.append("---")
            for k, v in front_matter.items():
                lines.append(f"{k}: {v}")
            lines.append("---\n")
        lines.append(f"# {title}\n")
        for sec in sorted(sections, key=lambda s: s.get("id", 0)):
            heading = f"## {sec.get('title', '').strip()}".strip()
            if heading:
                lines.append(heading)
            content = str(sec.get("content", "")).strip()
            if content:
                lines.append(content)
            lines.append("")
        markdown = "\n".join(lines).strip() + "\n"

        result: dict[str, Any] = {"content": markdown}

        # Optionally persist to workspace
        if output_path:
            out_path = Path(__file__).resolve().parents[1] / "workspace" / output_path
            out_path.parent.mkdir(parents=True, exist_ok=True)
            out_path.write_text(markdown, encoding="utf-8")
            result["path"] = str(out_path)
        return ToolResult(output="Report assembled", system="rendered", extra=result)
