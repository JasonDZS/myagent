from __future__ import annotations

from typing import Any, ClassVar, Sequence

from myagent.tool.base_tool import BaseTool, ToolResult

from .slide_types import SlideTask


def _ensure_string_list(values: Any) -> list[str]:
    if not values:
        return []
    if not isinstance(values, Sequence) or isinstance(values, (str, bytes)):
        raise ValueError(f"Expected a list of strings, got: {values}")
    return [str(item).strip() for item in values if str(item).strip()]


def _maybe_string(value: Any) -> str | None:
    if value is None:
        return None
    value_str = str(value).strip()
    return value_str or None


def _coerce_optional_bool(value: Any) -> bool | None:
    if value is None:
        return None
    if isinstance(value, bool):
        return value
    if isinstance(value, int) and value in (0, 1):
        return bool(value)
    if isinstance(value, str):
        lowered = value.strip().lower()
        if lowered in {"true", "1", "yes", "y"}:
            return True
        if lowered in {"false", "0", "no", "n"}:
            return False
    raise ValueError(f"Cannot interpret {value!r} as a boolean.")


def _normalize_slide_payload(slide: dict[str, Any]) -> dict[str, Any]:
    normalized = dict(slide)
    normalized.pop("is_cover", None)

    is_cover = _coerce_optional_bool(slide.get("isCover", slide.get("is_cover")))
    if is_cover is None and normalized.get("id") == 1:
        is_cover = True
    if is_cover is not None:
        normalized["isCover"] = is_cover
    else:
        normalized.pop("isCover", None)

    if "background" in normalized:
        background_value = normalized["background"]
        if background_value is None:
            normalized.pop("background")
        else:
            background_str = str(background_value).strip()
            if background_str:
                normalized["background"] = background_str
            else:
                normalized.pop("background")

    return normalized


def _parse_slide_task(task: dict[str, Any]) -> SlideTask:
    try:
        slide_id = int(task["id"])
        if slide_id <= 0:
            raise ValueError("Slide id must be positive.")
    except Exception as exc:  # pylint: disable=broad-except
        raise ValueError(f"Invalid slide id in task: {task}") from exc

    title = str(task["title"]).strip()
    objective = str(task["objective"]).strip()
    if not title or not objective:
        raise ValueError(f"Task {slide_id} is missing a title or objective.")

    insights = _ensure_string_list(task.get("insights", []))
    query_suggestions = _ensure_string_list(task.get("query_suggestions", []))
    chart_hint = _maybe_string(task.get("chart_hint"))
    notes = _maybe_string(task.get("notes"))

    return SlideTask(
        id=slide_id,
        title=title,
        objective=objective,
        insights=insights,
        query_suggestions=query_suggestions,
        chart_hint=chart_hint,
        notes=notes,
    )


class SlidePlanSubmissionTool(BaseTool):
    """Collect slide tasks generated by the planning agent.

    The pipeline retrieves tasks via `get_tasks()` after the tool is called.
    """

    name: str = "submit_slide_plan"
    description: str = (
        "Submit the finalized slide plan. Provide one task per slide with the required metadata."
    )
    parameters: ClassVar[dict[str, Any]] = {
        "type": "object",
        "properties": {
            "tasks": {
                "type": "array",
                "description": "List of slide generation tasks. Each task corresponds to one PPT slide.",
                "items": {
                    "type": "object",
                    "properties": {
                        "id": {"type": "integer", "description": "1-indexed slide identifier"},
                        "title": {"type": "string", "description": "Slide title"},
                        "objective": {
                            "type": "string",
                            "description": "What insight this slide must communicate",
                        },
                        "insights": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "Key points or findings the slide should cover",
                        },
                        "query_suggestions": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "SQL ideas worth attempting during slide creation",
                        },
                        "chart_hint": {
                            "type": "string",
                            "description": "Preferred chart type or layout suggestion",
                        },
                        "notes": {
                            "type": "string",
                            "description": "Additional context or assumptions for the solver",
                        },
                    },
                    "required": ["id", "title", "objective"],
                },
            }
        },
        "required": ["tasks"],
    }

    def __init__(self) -> None:
        super().__init__()
        self._tasks: list[SlideTask] = []

    async def execute(self, tasks: Sequence[dict[str, Any]]) -> ToolResult:
        try:
            parsed = [_parse_slide_task(task) for task in tasks]
        except ValueError as exc:
            return ToolResult(error=str(exc))

        ids = [task.id for task in parsed]
        if len(ids) != len(set(ids)):
            return ToolResult(error="Slide task IDs must be unique.")

        parsed.sort(key=lambda item: item.id)
        self._tasks = parsed

        overview_lines = ["âœ… Slide plan received:", *[f"- {task.short_summary()}" for task in parsed]]
        return ToolResult(
            output="\n".join(overview_lines),
            system=f"Slide planning completed with {len(parsed)} tasks",
        )

    def get_tasks(self) -> list[SlideTask]:
        return list(self._tasks)


class SlideDraftTool(BaseTool):
    """Capture final slide draft generated by a solve agent."""

    name: str = "submit_slide_draft"
    description: str = (
        "Submit the finalized slide draft. Provide slide id, title, narrative text, and optional charts."
    )
    parameters: ClassVar[dict[str, Any]] = {
        "type": "object",
        "properties": {
            "slide": {
                "type": "object",
                "properties": {
                    "id": {"type": "integer", "description": "Slide identifier"},
                    "title": {"type": "string", "description": "Slide title"},
                    "text": {
                        "type": "string",
                        "description": "Primary narrative text (single paragraph, <=100 characters, inline markdown ok)",
                    },
                    "charts": {
                        "type": "array",
                        "description": "Optional charts array (maximum 2 charts)",
                        "items": {
                            "type": "object",
                            "properties": {
                                "type": {
                                    "type": "string",
                                    "enum": ["bar", "line", "pie", "area"],
                                },
                                "title": {"type": "string"},
                                "data": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "name": {"type": "string"},
                                            "value": {"type": "number"},
                                        },
                                        "required": ["name", "value"],
                                    },
                                },
                                "horizontal": {"type": "boolean"},
                            },
                            "required": ["data"],
                        },
                    },
                    "layout": {"type": "string", "enum": ["single", "double"]},
                    "isCover": {
                        "type": "boolean",
                        "description": "Marks this slide as the presentation cover when true",
                    },
                    "background": {
                        "type": "string",
                        "description": "Optional slide background color or gradient value",
                    },
                },
                "required": ["id", "title", "text"],
            }
        },
        "required": ["slide"],
    }

    def __init__(self, expected_id: int | None = None) -> None:
        super().__init__()
        self._expected_id = expected_id
        self._slide: dict[str, Any] | None = None

    async def execute(self, slide: dict[str, Any]) -> ToolResult:
        if self._expected_id is not None and slide.get("id") != self._expected_id:
            return ToolResult(
                error=f"Slide id mismatch. Expected {self._expected_id}, received {slide.get('id')!r}."
            )

        validation_error = _validate_slide_payload(slide)
        if validation_error:
            return ToolResult(error=validation_error)

        try:
            normalized_slide = _normalize_slide_payload(slide)
        except ValueError as exc:
            return ToolResult(error=str(exc))

        self._slide = normalized_slide
        summary = f"Draft stored for slide {slide['id']}: {slide['title']}"
        return ToolResult(output=summary, system="Slide draft submission recorded")

    def get_slide(self) -> dict[str, Any] | None:
        return dict(self._slide) if self._slide else None


def _validate_slide_payload(slide: dict[str, Any]) -> str | None:
    required_fields = ("id", "title", "text")
    for field_name in required_fields:
        if field_name not in slide:
            return f"Slide payload missing required field: {field_name}"
        if not str(slide[field_name]).strip():
            return f"Slide field '{field_name}' cannot be empty."

    try:
        _coerce_optional_bool(slide.get("isCover", slide.get("is_cover")))
    except ValueError:
        return "Slide field 'isCover' must be a boolean when provided."

    background_value = slide.get("background")
    if background_value is not None:
        if not isinstance(background_value, str):
            return "Slide background must be a string when provided."
        if not background_value.strip():
            return "Slide background must be non-empty when provided."

    text_value = str(slide["text"]).strip()
    if len(text_value) > 100:
        return "Slide text must be 100 characters or fewer."
    if "\n" in text_value or "\r" in text_value:
        return "Slide text must be a single paragraph without line breaks."

    if not isinstance(slide["id"], int):
        return "Slide id must be an integer."

    charts = slide.get("charts", [])
    if charts:
        if not isinstance(charts, list):
            return "Charts must be a list."
        if len(charts) > 2:
            return "Slide cannot contain more than 2 charts."
        for chart in charts:
            if "data" not in chart:
                return "Each chart must include a 'data' field."
            data_points = chart["data"]
            if not isinstance(data_points, list) or not data_points:
                return "Chart data must be a non-empty list."
            for datapoint in data_points:
                if "name" not in datapoint or "value" not in datapoint:
                    return "Each data point requires 'name' and 'value'."
    return None
