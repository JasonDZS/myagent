"""Plan-first, solve-next Dataâ†’PPT pipeline built on the plan_solver framework."""

from __future__ import annotations

import argparse
import asyncio
from dataclasses import dataclass, field
from typing import Any, ClassVar, Sequence

from myagent import create_react_agent
from myagent.agent import (
    PlanAgent,
    PlanContext,
    PlanSolveResult,
    SolverAgent,
    SolverRunResult,
    create_plan_solver,
)
from myagent.tool.base_tool import BaseTool, ToolResult

from data2ppt import (
    DatabaseQueryTool,
    DatabaseSchemaTool,
    GeneratePPTTool,
    _load_database_config,
)


# --------------------------------------------------------------------------------------
# Shared data structures and helper tools
# --------------------------------------------------------------------------------------


@dataclass
class SlideTask:
    """Represents a single slide task produced by the plan agent."""

    id: int
    title: str
    objective: str
    insights: list[str] = field(default_factory=list)
    query_suggestions: list[str] = field(default_factory=list)
    chart_hint: str | None = None
    notes: str | None = None

    def short_summary(self) -> str:
        summary = f"[Slide {self.id}] {self.title}: {self.objective}"
        if self.insights:
            summary += f" | Insights: {', '.join(self.insights[:2])}"
        if self.chart_hint:
            summary += f" | Chart: {self.chart_hint}"
        return summary


class SlidePlanSubmissionTool(BaseTool):
    """Collects the slide tasks generated by the planning agent."""

    name: str = "submit_slide_plan"
    description: str = (
        "Submit the finalized slide plan. Provide one task per slide with the required metadata."
    )
    parameters: ClassVar[dict[str, Any]] = {
        "type": "object",
        "properties": {
            "tasks": {
                "type": "array",
                "description": "List of slide generation tasks. Each task corresponds to one PPT slide.",
                "items": {
                    "type": "object",
                    "properties": {
                        "id": {"type": "integer", "description": "1-indexed slide identifier"},
                        "title": {"type": "string", "description": "Slide title"},
                        "objective": {
                            "type": "string",
                            "description": "What insight this slide must communicate",
                        },
                        "insights": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "Key points or findings the slide should cover",
                        },
                        "query_suggestions": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "SQL ideas worth attempting during slide creation",
                        },
                        "chart_hint": {
                            "type": "string",
                            "description": "Preferred chart type or layout suggestion",
                        },
                        "notes": {
                            "type": "string",
                            "description": "Additional context or assumptions for the solver",
                        },
                    },
                    "required": ["id", "title", "objective"],
                },
            }
        },
        "required": ["tasks"],
    }

    def __init__(self) -> None:
        super().__init__()
        self._tasks: list[SlideTask] = []

    async def execute(self, tasks: Sequence[dict[str, Any]]) -> ToolResult:
        """Validate and store slide tasks."""
        try:
            parsed = [_parse_slide_task(task) for task in tasks]
        except ValueError as exc:
            return ToolResult(error=str(exc))

        ids = [task.id for task in parsed]
        if len(ids) != len(set(ids)):
            return ToolResult(error="Slide task IDs must be unique.")

        parsed.sort(key=lambda item: item.id)
        self._tasks = parsed

        overview_lines = ["âœ… Slide plan received:", *[f"- {task.short_summary()}" for task in parsed]]
        return ToolResult(
            output="\n".join(overview_lines),
            system=f"Slide planning completed with {len(parsed)} tasks",
        )

    def get_tasks(self) -> list[SlideTask]:
        """Expose collected slide tasks to the orchestrator."""
        return list(self._tasks)


def _parse_slide_task(task: dict[str, Any]) -> SlideTask:
    """Convert raw tool payload into a SlideTask with validation."""
    try:
        slide_id = int(task["id"])
        if slide_id <= 0:
            raise ValueError("Slide id must be positive.")
    except Exception as exc:  # pylint: disable=broad-except
        raise ValueError(f"Invalid slide id in task: {task}") from exc

    title = str(task["title"]).strip()
    objective = str(task["objective"]).strip()
    if not title or not objective:
        raise ValueError(f"Task {slide_id} is missing a title or objective.")

    insights = _ensure_string_list(task.get("insights", []))
    query_suggestions = _ensure_string_list(task.get("query_suggestions", []))
    chart_hint = _maybe_string(task.get("chart_hint"))
    notes = _maybe_string(task.get("notes"))

    return SlideTask(
        id=slide_id,
        title=title,
        objective=objective,
        insights=insights,
        query_suggestions=query_suggestions,
        chart_hint=chart_hint,
        notes=notes,
    )


def _ensure_string_list(values: Any) -> list[str]:
    if not values:
        return []
    if not isinstance(values, Sequence) or isinstance(values, (str, bytes)):
        raise ValueError(f"Expected a list of strings, got: {values}")
    return [str(item).strip() for item in values if str(item).strip()]


def _maybe_string(value: Any) -> str | None:
    if value is None:
        return None
    value_str = str(value).strip()
    return value_str or None


def _coerce_optional_bool(value: Any) -> bool | None:
    if value is None:
        return None
    if isinstance(value, bool):
        return value
    if isinstance(value, int) and value in (0, 1):
        return bool(value)
    if isinstance(value, str):
        lowered = value.strip().lower()
        if lowered in {"true", "1", "yes", "y"}:
            return True
        if lowered in {"false", "0", "no", "n"}:
            return False
    raise ValueError(f"Cannot interpret {value!r} as a boolean.")


def _normalize_slide_payload(slide: dict[str, Any]) -> dict[str, Any]:
    normalized = dict(slide)
    normalized.pop("is_cover", None)

    is_cover = _coerce_optional_bool(slide.get("isCover", slide.get("is_cover")))
    if is_cover is None and normalized.get("id") == 1:
        is_cover = True
    if is_cover is not None:
        normalized["isCover"] = is_cover
    else:
        normalized.pop("isCover", None)

    if "background" in normalized:
        background_value = normalized["background"]
        if background_value is None:
            normalized.pop("background")
        else:
            background_str = str(background_value).strip()
            if background_str:
                normalized["background"] = background_str
            else:
                normalized.pop("background")

    return normalized


class SlideDraftTool(BaseTool):
    """Captures the slide draft generated by a solve agent."""

    name: str = "submit_slide_draft"
    description: str = (
        "Submit the finalized slide draft. Provide slide id, title, narrative text, and optional charts."
    )
    parameters: ClassVar[dict[str, Any]] = {
        "type": "object",
        "properties": {
            "slide": {
                "type": "object",
                "properties": {
                    "id": {"type": "integer", "description": "Slide identifier"},
                    "title": {"type": "string", "description": "Slide title"},
                    "text": {
                        "type": "string",
                        "description": "Primary narrative text (single paragraph, <=100 characters, inline markdown ok)",
                    },
                    "charts": {
                        "type": "array",
                        "description": "Optional charts array (maximum 2 charts)",
                        "items": {
                            "type": "object",
                            "properties": {
                                "type": {
                                    "type": "string",
                                    "enum": ["bar", "line", "pie", "area"],
                                },
                                "title": {"type": "string"},
                                "data": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "name": {"type": "string"},
                                            "value": {"type": "number"},
                                        },
                                        "required": ["name", "value"],
                                    },
                                },
                                "horizontal": {"type": "boolean"},
                            },
                            "required": ["data"],
                        },
                    },
                    "layout": {"type": "string", "enum": ["single", "double"]},
                    "isCover": {
                        "type": "boolean",
                        "description": "Marks this slide as the presentation cover when true",
                    },
                    "background": {
                        "type": "string",
                        "description": "Optional slide background color or gradient value",
                    },
                },
                "required": ["id", "title", "text"],
            }
        },
        "required": ["slide"],
    }

    def __init__(self, expected_id: int | None = None) -> None:
        super().__init__()
        self._expected_id = expected_id
        self._slide: dict[str, Any] | None = None

    async def execute(self, slide: dict[str, Any]) -> ToolResult:
        """Validate and store the slide draft."""
        if self._expected_id is not None and slide.get("id") != self._expected_id:
            return ToolResult(
                error=f"Slide id mismatch. Expected {self._expected_id}, received {slide.get('id')!r}."
            )

        validation_error = _validate_slide_payload(slide)
        if validation_error:
            return ToolResult(error=validation_error)

        try:
            normalized_slide = _normalize_slide_payload(slide)
        except ValueError as exc:
            return ToolResult(error=str(exc))

        self._slide = normalized_slide
        summary = f"Draft stored for slide {slide['id']}: {slide['title']}"
        return ToolResult(output=summary, system="Slide draft submission recorded")

    def get_slide(self) -> dict[str, Any] | None:
        """Expose stored slide draft to the orchestrator."""
        return dict(self._slide) if self._slide else None


def _validate_slide_payload(slide: dict[str, Any]) -> str | None:
    required_fields = ("id", "title", "text")
    for field_name in required_fields:
        if field_name not in slide:
            return f"Slide payload missing required field: {field_name}"
        if not str(slide[field_name]).strip():
            return f"Slide field '{field_name}' cannot be empty."

    try:
        _coerce_optional_bool(slide.get("isCover", slide.get("is_cover")))
    except ValueError:
        return "Slide field 'isCover' must be a boolean when provided."

    background_value = slide.get("background")
    if background_value is not None:
        if not isinstance(background_value, str):
            return "Slide background must be a string when provided."
        if not background_value.strip():
            return "Slide background must be non-empty when provided."

    text_value = str(slide["text"]).strip()
    if len(text_value) > 100:
        return "Slide text must be 100 characters or fewer."
    if "\n" in text_value or "\r" in text_value:
        return "Slide text must be a single paragraph without line breaks."

    if not isinstance(slide["id"], int):
        return "Slide id must be an integer."

    charts = slide.get("charts", [])
    if charts:
        if not isinstance(charts, list):
            return "Charts must be a list."
        if len(charts) > 2:
            return "Slide cannot contain more than 2 charts."
        for chart in charts:
            if "data" not in chart:
                return "Each chart must include a 'data' field."
            data_points = chart["data"]
            if not isinstance(data_points, list) or not data_points:
                return "Chart data must be a non-empty list."
            for datapoint in data_points:
                if "name" not in datapoint or "value" not in datapoint:
                    return "Each data point requires 'name' and 'value'."
    return None


# --------------------------------------------------------------------------------------
# Plan/Solve agent implementations
# --------------------------------------------------------------------------------------


class Data2PPTPlanAgent(PlanAgent):
    """Plan agent responsible for producing slide-sized tasks."""

    def __init__(self) -> None:
        super().__init__(name="ppt_plan_agent")
        self._plan_tool = SlidePlanSubmissionTool()
        self._schema_tool = DatabaseSchemaTool()
        self._query_tool = DatabaseQueryTool()

    def build_agent(self) -> Any:
        return create_react_agent(
            name=self.name,
            tools=[self._plan_tool, self._schema_tool, self._query_tool],
            system_prompt=(
                "You are the planning coordinator for a PPT analytics project.\n\n"
                "## Responsibilities\n"
                "- Inspect the database structure with db_schema (and sample data with db_query if helpful).\n"
                "- Understand the user's presentation goal and break it into slide-sized tasks.\n"
                "- Each task must correspond to exactly one PPT slide.\n"
                "- When the plan is ready, call submit_slide_plan ONCE with all tasks.\n\n"
                "## Task structure requirements\n"
                "- Use sequential slide ids starting from 1.\n"
                "- Always dedicate slide id 1 to the presentation cover page (title plus optional subtitle/presenter/date).\n"
                "- Provide a concise title and a clear objective for each slide.\n"
                "- Add optional insights, SQL suggestions, or chart hints when they help the solvers.\n"
                "- Do not attempt to generate slides yourself â€“ only plan the work.\n"
                "- After submitting the plan, summarize the reasoning and next steps in your final answer."
            ),
            next_step_prompt=(
                "Planning guide:\n"
                "1. Review the question and inspect the database if needed.\n"
                "2. Draft slide-level tasks and refine them.\n"
                "3. Call submit_slide_plan with all tasks once the plan is solid.\n"
                "4. Provide a short recap confirming the slide plan.\n"
                "5. When finished, use the terminate tool."
            ),
            max_steps=25,
            max_observe=1500,
        )

    def extract_tasks(self, agent: Any, plan_output: str) -> Sequence[SlideTask]:
        tasks = self._plan_tool.get_tasks()
        return tasks

    def extract_summary(self, agent: Any, plan_output: str) -> str | None:
        if getattr(agent, "final_response", None):
            return agent.final_response  # type: ignore[attr-defined]
        return plan_output

    def coerce_tasks(self, tasks: Sequence[Any]) -> Sequence[Any]:
        """Coerce user-edited tasks (dicts) into SlideTask objects when needed."""
        coerced: list[SlideTask] = []
        for t in tasks:
            if isinstance(t, SlideTask):
                coerced.append(t)
            elif isinstance(t, dict):
                coerced.append(_parse_slide_task(t))
            else:
                raise ValueError(f"Unsupported task payload type: {type(t)}")
        return coerced


class Data2PPTSlideSolver(SolverAgent):
    """Solver agent that turns a single slide task into a PPT-ready draft."""

    def __init__(self) -> None:
        super().__init__(name="ppt_slide_solver")
        self._schema_tool = DatabaseSchemaTool()
        self._query_tool = DatabaseQueryTool()
        self._draft_tools: dict[int, SlideDraftTool] = {}

    def build_agent(self, task: SlideTask, *, context: PlanContext) -> Any:
        draft_tool = SlideDraftTool(expected_id=task.id)
        self._draft_tools[task.id] = draft_tool
        return create_react_agent(
            name=f"{self.name}_{task.id}",
            tools=[self._schema_tool, self._query_tool, draft_tool],
            system_prompt=(
                "You are a PPT slide specialist focused on one slide.\n\n"
                "## Responsibilities\n"
                "- Use db_schema and db_query to gather evidence supporting this slide's objective.\n"
                "- Synthesize clear insights and translate them into compelling narrative text.\n"
                "- Keep slide text to one paragraph (<=100 characters). Inline Markdown for emphasis/color is ok; no lists or line breaks.\n"
                "- Limit each slide to at most two charts.\n"
                "- Build chart-ready data when a visualization strengthens the message.\n"
                "- Submit the final slide via submit_slide_draft (exactly once) with id/title/text and optional charts.\n"
                "- Do NOT call generate_ppt; the orchestrator handles compilation.\n\n"
                "Ensure the slide is self-contained and action-oriented."
            ),
            next_step_prompt=(
                "Execution guide:\n"
                "1. Review the task brief.\n"
                "2. Explore data as needed using db_schema/db_query.\n"
                "3. Summarize insights and craft <=100 character single-paragraph text (inline Markdown ok; no line breaks or lists).\n"
                "4. Ensure charts are relevant (<=2) and call submit_slide_draft once ready.\n"
                "5. Confirm completion and highlight key takeaways.\n"
                "6. When finished, use the terminate tool."
            ),
            max_steps=25,
            max_observe=1500,
        )

    def build_request(self, task: SlideTask, *, context: PlanContext) -> str:
        parts = [
            f"Slide #{task.id}: {task.title}",
            f"Objective: {task.objective}",
        ]
        if task.insights:
            parts.append("Suggested insights:\n- " + "\n- ".join(task.insights))
        if task.query_suggestions:
            parts.append("SQL ideas:\n- " + "\n- ".join(task.query_suggestions))
        if task.chart_hint:
            parts.append(f"Chart hint: {task.chart_hint}")
        if task.notes:
            parts.append(f"Additional notes: {task.notes}")
        return "\n\n".join(parts)

    def extract_result(
        self, agent: Any, solver_output: str, task: SlideTask, *, context: PlanContext
    ) -> dict[str, Any]:
        draft_tool = self._draft_tools.pop(task.id, None)
        slide = draft_tool.get_slide() if draft_tool else None
        if not slide:
            raise RuntimeError(f"Solver for slide {task.id} did not submit a slide draft.")
        return slide

    def extract_summary(
        self, agent: Any, solver_output: str, task: SlideTask, *, context: PlanContext
    ) -> str | None:
        if getattr(agent, "final_response", None):
            return agent.final_response  # type: ignore[attr-defined]
        return f"Slide {task.id}: {task.title} draft ready."


# --------------------------------------------------------------------------------------
# Aggregation and orchestration helpers
# --------------------------------------------------------------------------------------


async def compile_presentation(
    context: PlanContext, results: Sequence[SolverRunResult]
) -> dict[str, Any]:
    """Aggregate solver outputs into a PPT JSON using GeneratePPTTool."""
    slides: list[dict[str, Any]] = []
    for item in results:
        slide = item.output
        if not isinstance(slide, dict):
            raise RuntimeError(f"Solver output is not a slide dict: {slide!r}")
        if "id" not in slide:
            raise RuntimeError(f"Slide dict missing 'id': {slide!r}")
        slides.append(_normalize_slide_payload(slide))

    slides.sort(key=lambda s: s.get("id", 0))
    ppt_tool = GeneratePPTTool()
    ppt_result = await ppt_tool.execute(slides=slides)  # type: ignore[arg-type]
    return {"slides": slides, "ppt_result": ppt_result}


def _print_result(report: PlanSolveResult) -> None:
    print("\n" + "=" * 80)
    print("ğŸ“‹ Planning Summary")
    print("=" * 80)
    if report.plan_summary:
        print(report.plan_summary)
    else:
        print("No explicit planning summary generated.")

    print("\nğŸ—‚ Slide Tasks:")
    for task in report.tasks:
        if isinstance(task, SlideTask):
            print(f"- {task.short_summary()}")
        else:
            print(f"- {task!r}")

    print("\n" + "=" * 80)
    print("ğŸ›  Solver Highlights")
    print("=" * 80)
    for result in report.solver_results:
        summary = result.summary or f"Slide {getattr(result.task, 'id', '?')}: completed."
        print(f"- {summary}")

    aggregate = report.aggregate_output
    if isinstance(aggregate, dict) and "ppt_result" in aggregate:
        ppt_result = aggregate["ppt_result"]
        print("\n" + "=" * 80)
        print("ğŸ“Š PPT Generation")
        print("=" * 80)
        if isinstance(ppt_result, ToolResult):
            if ppt_result.output:
                print(ppt_result.output)
            elif ppt_result.error:
                print(f"Error: {ppt_result.error}")
            else:
                print("PPT tool completed without textual output.")
        else:
            print(aggregate)
    elif aggregate is not None:
        print("\nAggregate output:")
        print(aggregate)


async def orchestrate(question: str) -> None:
    """End-to-end orchestration: plan â†’ parallel solve â†’ compile."""
    config = _load_database_config()
    print(f"Database: {config.database} ({config.db_type.value})")
    print(f"Question: {question}\n")

    pipeline = create_plan_solver(
        name="plan_solve_data2ppt",
        planner=Data2PPTPlanAgent(),
        solver=Data2PPTSlideSolver(),
        aggregator=compile_presentation,
    )

    result = await pipeline.run(question)
    _print_result(result)

    aggregate = result.aggregate_output
    if isinstance(aggregate, dict) and isinstance(aggregate.get("ppt_result"), ToolResult):
        print(
            "\nğŸ’¡ Slides saved to ./workdir/ppt/presentation.json "
            "ï¼ˆå¦‚æœªæ‰¾åˆ°æ–‡ä»¶ï¼Œè¯·æ£€æŸ¥ generate_ppt æ˜¯å¦æˆåŠŸæ‰§è¡Œï¼‰"
        )


# --------------------------------------------------------------------------------------
# CLI entry point
# --------------------------------------------------------------------------------------


async def main() -> None:
    parser = argparse.ArgumentParser(
        description="Plan/Solve multi-agent pipeline for database analytics to PPT."
    )
    parser.add_argument(
        "question",
        nargs="?",
        default="è¯·åˆ†æé”€å”®æ•°æ®åº“å¹¶ç”Ÿæˆä¸€ä»½åŒ…å«å…³é”®æŒ‡æ ‡å’Œè¶‹åŠ¿çš„å¤šé¡µPPTæŠ¥å‘Š",
        help="High-level analysis request that the plan agent will decompose.",
    )
    args = parser.parse_args()

    await orchestrate(args.question)


if __name__ == "__main__":
    asyncio.run(main())
